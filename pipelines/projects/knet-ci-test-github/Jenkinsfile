// Jenkinsfile for the knet CI (github) project
//  1-May-2023    Chrissie Caulfield    original version for running 'old-style' jobs
// 16-Jun-2023    me again              Move a lot of stuff into getBuildInfo() for tidiness
// 13-Jul-2023    guess who?            Make it fully pipelined

@Library(['GlobalLib@cc-devel', 'GithubLib@cc-devel', 'ProjectLib@cc-devel']) _

// Who we are
def project = 'ci-test'

// Pipeline code starts here
pipeline {
    // Start on the main Jenkins node. Build jobs are distributed inside 'parallel' below
    agent { label 'built-in' }

    // Things that external jobs might want to influence
    parameters {
	string(name: 'bootstrap',   defaultValue: '0', description: 'Bootstrap the RPM repos')
	string(name: 'fullrebuild', defaultValue: '0', description: 'This is a full rebuild - do not publish RPM and do NOT update build code on the nodes')
    }

    stages {
	// First check we are allowed to run, then set some params for that run
	stage('Setup build env') {
	    steps {
		script {
		    info = getBuildInfo(project)
		    info['bootstrap'] = '1' // for this test job only.
		}
	    }
	}

        // This is the main stage - building and testing
	stage('Main stage') {
	    when {
		// getAuthCheck (in getBuildInfo) will usually abort the job if permission is denied,
		// but this is an extra check.
		expression { info['authcheck'] == true && info['is_draft'] == false }
	    }

	    // All of the stages that actually do stuff
	    steps {
		script {
		    cleanWs(disableDeferredWipeout: true, deleteDirs: true)

		    // The 'short' test list
		    voting = buildRunMap('voting', info, ['voting': true,
							  'nodelabel': 'test-voting',
							  'extravars': ['kronosnetver': 'main',
									'justforfun': 'BOO',
									'install': '0']])
		    nonvoting = buildRunMap('nonvoting', info, ['voting': false,
								'nodelabel': 'test-nonvoting',
								'extravars': ['kronosnetver': 'stable1']])
		    nonvoting_clang = buildRunMap('nonvoting-clang', info, ['voting': false,
									    'nodelabel': 'test-nonvoting',
									    'extravars': ['compiler': 'clang',
											  'install': '0',
											  'title': 'CLANG test']])

//		    covscan = buildRunMap('covscan', info, ['voting': true,
//							    'nodelabel': 'test-covscan'])
		    buildrpms = buildRunMap('buildrpms', info, ['voting': true,
								'nodelabel': 'test-buildrpms'])


		    // This is the libqb list ...
		    // voting = buildRunMap('voting', info, ['voting': true,
		    // 					  'nodelabel': 'voting',
		    // 					  'nodelist': ['debian-unstable-cross-x86-64']])
		    // nonvoting = buildRunMap('nonvoting', info, ['voting': false,
		    // 						'nodelabel': 'nonvoting'])
		    // nonvoting_clang = buildRunMap('nonvoting-clang', info, ['voting': false,
		    // 							    'nodelabel': 'nonvoting-clang'])
		    // covscan = buildRunMap('covscan', info, ['voting': true,
		    // 					    'nodelabel': 'covscan'])
		    // buildrpms = buildRunMap('buildrpms', info, ['voting': false,
		    //                                             'nodelabel': 'buildrpms'])

		    // Run them (errors are caught in info[:])
		    try {
			parallel voting + nonvoting + nonvoting_clang + buildrpms
		    } catch (err) {
			println("Jenkinsfile caught "+err)
			info['exception_text'] += "\nparallel error caught: {$err}\n"
		    }
		}
	    }
	}

        // Build the RPM/Coverity repos etc. If the job failed, this is what tells Jenkins
	stage('Post Stage') {
	    when {
		expression { info['authcheck'] == true && info['is_draft'] == false }
	    }
	    steps {
		postStage(info)
	    }
	}
    }

    // Finish up and send emails
    post {
	always {
	    sendEmails(info)
	}
    }
}
